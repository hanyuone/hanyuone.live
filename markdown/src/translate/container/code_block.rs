use syntect::{
    easy::HighlightLines,
    highlighting::{Color, Style},
    parsing::SyntaxReference,
    util::LinesWithEndings,
};

use crate::translate::{
    element::{AttributeName, ElementTag, RenderElement},
    error::TranslateError,
    highlight::{SYNTAX_SET, THEME_SET},
    node::RenderNode,
};

use super::Container;

pub struct CodeBlock<'a> {
    language: Option<&'a SyntaxReference>,
    contents: String,
}

impl<'a> CodeBlock<'a> {
    pub fn new(language: Option<&'a SyntaxReference>) -> Self {
        Self {
            language,
            contents: String::new(),
        }
    }

    pub fn add_child(&mut self, child: RenderNode) {
        let RenderNode::Text(contents) = child else {
            unreachable!();
        };

        self.contents = contents;
    }

    /// Creates an "unstyled" code block (i.e. no syntax highlighting).
    fn to_unstyled_node(&self) -> RenderNode {
        let mut unstyled = RenderElement::new(ElementTag::Pre);

        let mut code = RenderElement::new(ElementTag::Code);
        code.add_child(RenderNode::Text(self.contents.clone()));

        unstyled.add_child(code.into());
        return unstyled.into();
    }
}

/// Converts a list of tokens generated by `syntect` (i.e. chunks of text associated
/// with a style) into `span` blocks represented by `RenderElement`s. Combines
/// tokens with the same style to reduce space on encoding.
fn to_nodes(token_lines: Vec<Vec<(Style, &str)>>) -> Vec<RenderNode> {
    let mut nodes = vec![];

    for mut line in token_lines {
        // Never panics, `line` is guaranteed to be non-empty
        let (last, butlast) = line.split_last_mut().unwrap();

        // Trim newline from last token
        let last_trimmed = last.1.trim_end();

        // If trimmed last element is empty, bin it and add newline later
        let line = if last_trimmed.is_empty() {
            butlast
        } else {
            *last = (last.0, last_trimmed);
            &mut line
        };

        // Condense all spans with the same style into one element, to save space
        let mut condensed = line
            .chunk_by(|(a_style, _), (b_style, _)| a_style == b_style)
            .map(|chunk| {
                let style = chunk[0].0;
                let contents = chunk
                    .iter()
                    .map(|(_, contents)| contents.to_string())
                    .collect::<String>();

                let mut node = RenderElement::new(ElementTag::Span);

                let Color { r, g, b, .. } = style.foreground;
                let colour_css = format!("color: rgb({}, {}, {})", r, g, b);
                node.add_attribute(AttributeName::Style, colour_css);

                node.add_child(RenderNode::Text(contents));
                node.into()
            })
            .collect::<Vec<RenderNode>>();

        nodes.append(&mut condensed);

        // Add newline back
        nodes.push(RenderNode::Text("\n".to_string()));
    }

    nodes
}

impl<'a> TryFrom<CodeBlock<'a>> for RenderNode {
    type Error = TranslateError;

    fn try_from(value: CodeBlock) -> Result<Self, Self::Error> {
        let Some(language) = value.language else {
            return Ok(value.to_unstyled_node());
        };

        let mut styled = RenderElement::new(ElementTag::Pre);
        let mut code = RenderElement::new(ElementTag::Code);

        // Set up highlighter and syntect tokens
        let theme = &THEME_SET.themes["base16-ocean.dark"];
        let mut highlighter = HighlightLines::new(language, theme);

        let token_liens = LinesWithEndings::from(&value.contents)
            .map(|line| highlighter.highlight_line(line, &SYNTAX_SET))
            .collect::<Result<Vec<_>, _>>()
            .map_err(|_| TranslateError::CodeHighlightError)?;

        let span_nodes = to_nodes(token_liens);

        for node in span_nodes {
            code.add_child(node);
        }

        styled.add_child(code.into());
        Ok(styled.into())
    }
}

impl<'a> From<CodeBlock<'a>> for Container<'a> {
    fn from(value: CodeBlock<'a>) -> Self {
        Self::CodeBlock(value)
    }
}
